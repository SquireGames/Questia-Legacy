#ifndef TILEENGINE_H
#define TILEENGINE_H

#include "Data_Desktop.h"
#include "ResourceManager.h"

#include "EntityManager/Entity/Collidable/Entity_Collidable.h"
#include <map>

#include <SFML/Graphics.hpp>

#include "Utl.h"
#include "SpriteSheet.h"

///not stored in actual map but moved and drawn to screen
class Tile
{
public:
    Tile(sf::RenderWindow& _window, ResourceManager& _resourceManager):
        window(_window)
        , resourceManager(_resourceManager)
    {

    }
    ~Tile()
    {

    }

    //tile animated or static
    enum class TileType {sprite, animation};
    TileType tileType = TileType::sprite;

    //draws tile
    void drawTile()
    {
        switch(tileType)
        {
        case TileType::sprite:
            window.draw(tileSprite);
            break;
        case TileType::animation:
            break;
        }
    }

    //tile init
    void setTexture(std::string filePath)
    {
        switch(tileType)
        {
        case TileType::sprite:
            tileSprite.setTexture(resourceManager.getTexture(filePath));
            break;
        case TileType::animation:
            break;
        }
    }
    void setPosition(int x, int y)
    {
        switch(tileType)
        {
        case TileType::sprite:
            tileSprite.setPosition(64 * x, 64 * y);
            break;
        case TileType::animation:
            break;
        }
    }
    void setSize(unsigned int tilesWidth, unsigned int tilesHeight)
    {
        switch(tileType)
        {
        case TileType::sprite:
            tileSprite.setScale(tile64 * tilesWidth, 64 * tilesHeight);
            break;
        case TileType::animation:
            break;
        }
    }
    void setRotate(unsigned int degrees)
    {
        switch(tileType)
        {
        case TileType::sprite:
            break;
        case TileType::animation:
            break;
        }
    }
    void setFlip(utl::Direction direction)
    {
        switch(tileType)
        {
        case TileType::sprite:
            break;
        case TileType::animation:
            break;
        }
    }

    //vars for saving
    int index = -1, id = -1;

private:
    //possible types to render
    sf::Sprite tileSprite;
    //SpriteSheetNew tileSpriteSheet;

    //default
    sf::RenderWindow& window;
    ResourceManager& resourceManager;
};

class TileEngineNew
{
public:
    //ctor and dtor
    TileEngineNew(sf::RenderWindow& _window, ResourceManager& _resourceManager);
    ~TileEngineNew();

    //loads map
    void loadMap(std::string mapName);

    //draws map
    void drawMap();

    //set tiles drawn from player position
    void setPosition(int x, int y);

protected:
    ///map
    //stores tiles
    std::map <std::pair <int, int>, Tile> tileStorage;

    //stores map
    std::vector <utl::Vector2ui> tileMap;
    //stores map dimensions
    unsigned int mapWidth = 0, mapHeight = 0, mapLayers = 0;
    //largest tile in map for tile culling
    unsigned int maxTileSize_x = 1, mapTileSize_y = 1;

    //tiles fit on screen
    const unsigned int tileFit_x = (1920.f / 64.f) + 2; // +2 for transitioning tiles
    const unsigned int tileFit_y = (1080.f / 64.f) + 2; // +2 for transitioning tiles

    ///data
    utl::Vector2i cameraPosition;


    ///helpers
    //for map
    int getTile(unsigned int x, unsigned int y, unsigned int layer);
    //for getting tile
    int getTile(unsigned int x, unsigned int y);

    ///default
    sf::RenderWindow &window;
    ResourceManager& resourceManager;
};

class TileEngineNew_Editor : public TileEngineNew
{
    //ctor
    TileEngineNew_Editor(sf::RenderWindow& _window, ResourceManager& _resourceManager): TileEngineNew(_window, _resourceManager) {}
};













class TileEngine
{
public:
    TileEngine(sf::RenderWindow &_window, ResourceManager& _resourceManager);
    ~TileEngine();
    sf::RenderWindow &window;

    void drawMap(sf::Vector2f coordinates);
    int getMapCollision(sf::Vector2i mapCoordinates,sf::Vector2f playerCoordinates, sf::Vector2f getSideRadius, sf::Vector2f velocity, int (&returnCollision)[4]);
    void loadTiles(float x, float y, int index, int id);
    void loadTiles(float x, float y, int index, int id, int transparency);
    void loadMap(std::string mapName, bool isLimitingTextures);
    std::vector <sf::Vector2i> usedTileVector;

    std::map <int, std::map <int, sf::Sprite > > tileIndex;
    int mapHeight, mapWidth;

    //File locations
    std::string mapDir;
    std::string mapDir2;
    std::string mapTiles;

    // EDITOR ONLY
    void setMapVector (std::vector<std::vector <sf::Vector2i> > MapVector, int layer);
    std::vector<std::vector <sf::Vector2i> > getMapVector(int layer);

private:
    //local functions
    bool tileIsUsed(int index, int id, bool isLimitingTextures);
    void local_loadMap(std::string mapName, int layer, bool isLimitingTextures);
    void updateUsedTileList();

    std::map <int,std::vector <std::vector <sf::Vector2i> > > tileMap;

    ResourceManager& resourceManager;
};

#endif // TILEENGINE_H
