#ifndef MULTIPLAYERMANAGER_H
#define MULTIPLAYERMANAGER_H

#include <SFML/Network.hpp>
#include <SFML/System.hpp>
#include <string>
#include <iostream>
#include <map>

#include "Server.h"


//}

class MultiplayerManager
{
public:
    MultiplayerManager(std::string _serverName):
        server(nullptr)
        , thread_client_main(&MultiplayerManager::client_mainThread, this)
        , thread_host_main  (&MultiplayerManager::host_mainThread,   this)
        , thread_host_tcp   (&MultiplayerManager::host_udpThread,    this)
        , host_terminate  (false)
        , host_dead_main  (true)
        , host_dead_tcp   (true)
        , isRunningServer (false)
    {

    }
    ~MultiplayerManager()
    {

    }

    ///Server

    //main thread, handles tcp
    void host_mainThread()
    {
        Server server;

        float tickRate = 5.f;

        sf::Time timePerUpdate = sf::seconds(1.f/tickRate);
        sf::Clock clock;
        sf::Time timeSinceLastUpdate = sf::Time::Zero;

        sf::Lock mutexLock(host_terminateMutex);

        host_terminateMutex.lock();
        while(!host_terminate)
        {
            host_terminateMutex.unlock();

            sf::Time elapsedTime = clock.restart();
            timeSinceLastUpdate += elapsedTime;

            while (timeSinceLastUpdate > timePerUpdate)
            {
                timeSinceLastUpdate -= timePerUpdate;
                server.update();
            }

            sf::sleep(timePerUpdate/10.f);

            host_terminateMutex.lock();
        }
        host_terminateMutex.unlock();
    }
    //secondary thread, handles udp
    void host_udpThread()
    {

    }
    void startHostingServer()
    {
        if(!isRunningServer)
        {
            host_terminateMutex.lock();
            host_terminate = false;
            host_terminateMutex.unlock();

            host_deadMutex.lock();
            host_dead_main = true;
            host_dead_tcp = true;

            thread_host_main.launch();
            isRunningServer = true;
        }
    }
    void terminateHost()
    {
        if(isRunningServer)
        {
            host_terminateMutex.lock();
            host_terminate = true;
            host_terminateMutex.unlock();
        }
    }

    ///client

    void client_mainThread()
    {

    }
    void joinServer()
    {
        if(isRunningServer)
        {

        }
    }

    ///manager

    void update()
    {
        if(isRunningServer)
        {
            host_deadMutex.lock();
            if(host_dead_main && host_dead_tcp)
            {
                isRunningServer = false;
            }
            host_deadMutex.unlock();
        }
    }

private:
    Server* server;

    ///server
    //terminate
    sf::Mutex host_terminateMutex;
    bool      host_terminate;
    //check if alive
    sf::Mutex host_deadMutex;
    bool      host_dead_main;
    bool      host_dead_tcp;

    ///threads
    sf::Thread thread_host_main;
    sf::Thread thread_host_tcp;
    sf::Thread thread_client_main;

    ///thread safe
    bool isRunningServer;
};

#endif // MULTIPLAYERMANAGER_H
